
TODO:

 - If contexts are the same between routers, don't blow up
 - rejigger serving structure:
   - Run root middleware first, THEN do routing.
 - 500 handling:
   - write test for panic in middleware
   - write test for panics when contexts are the same between routers
 - Question: should i embed a ptr or the actual struct?
   - Not until I start benchmarking and pprofing
 - 404:
   - Since 404 is called after we handle our root middleware, we have a root context. 404 handler should accept a root context
 - 404 + logging
 - refactor all validation methods
   - good error messaging
   - proper logging
 - benchmarks
 - change reponsewriter to be an interface
 - change middleware to pass rw, r into next middleware
 - do further routing tests. Test tree.go. Wildcards.
 
 - refactor tests to use assertResponse

 - ??? Unsure thoughts
   - Wrap the request with some stuff that gives you a nice view of the params


Handlers:

type MyContext struct {
  RequestIdentifier string
  Db *gorp.Db
}

func (c *MyContext) Signin(w web.ResponseWriter, r *http.Request) {
  w.Fprintf("<html>...")
}

type AdminContext struct {
  *MyContext
  Admin *User
}

router = web.New(MyContext{})

router.AddMiddleware((*MyContext).Utf8Sanitizer).
       AddMiddleware((*MyContext).SetupConnections).
       AddMiddleware((*MyContext).FindSubdomain)

router.Get("/admin/signin", (*MyContext).Signin)
router.Post("/admin/signin", (*MyContext).CreateSession)

adminRouter := router.NewSubrouter(AdminContext{})
adminRouter.Namespace("/admin").                      // All this does is prefix any inner route with "/admin"
            AddMiddleware((*AdminContext).AdminRequired)

adminRouter.Get("/users", (*AdminContext).UsersListHandler)
adminRouter.Get("/users/:id(/\d.*/)", (*AdminContext).UsersShowHandler)
adminRouter.Post("/users", (*AdminContext).UsersCreateHandler)




// Idea
type TicketsController struct {
  *MyContext
}
adminRouter.Resources("tickets", TicketsController{}, "create", "update")
adminRouter.JsonResources("tickets", TicketsController{}, "create", "update")
// -> Assumes:
func (t *TicketsController) Create() {

}
// funcs: Create, Update, List, Show, Edit, New, Delete

General routing principles: order doesn't matter. Instead, we construct, a unique non-ambiguous routing tree


- This is just a library, not a framework. It handles HTTP Request -> [web library] -> your function.
                                                                        |-> your middleware/filters/callbacks
- It does NOT handle view/templating or ORM concerns.
- It WILL come with some utilities to auto-recompile source on page load, view errors in browser, etc
- Can have multiple independent routers listening on different hosts / ports
-